# 第三章：你需要一个收纳系统

---

上个月我去了一趟市图书馆。

不是为了借书，是为了帮朋友找一本绝版的摄影集。那是一座老图书馆，藏书量大概有几十万册。我走进去的时候心里其实没什么底——几十万本书，找一本特定的，听起来像大海捞针。

结果三分钟就找到了。

进门看导览牌：摄影类在三楼。上三楼看区域标识：艺术摄影在C区。走到C区看书架标签：按作者姓氏字母排列。手指划过书脊，十秒钟，到手。

几十万本书。三分钟。

走出图书馆的时候我突然想到一个让我很不舒服的对比：我的项目才六万行代码，为什么我在里面"找东西"要花那么久？

图书馆的几十万本书，我三分钟能定位任意一本。我的六万行代码，我想找到"计时器暂停时的状态保存逻辑"，得在文件列表里翻来翻去，打开三四个文件确认，有时候还找错。

差别在哪？

不在数量。图书馆的书比我的代码多多了。差别在于图书馆有一套分类系统——楼层、区域、书架、字母排序——而我的代码没有。

---

## 数量不是问题，没有分类才是

这个发现让我重新审视了第二章里那个"不对称的赛跑"。

我之前一直觉得问题出在"代码太多了"。六万行，太大了，大脑装不下，所以掉队了。这个诊断听起来合理，但它暗含了一个很绝望的结论——如果问题是代码太多，那怎么办？删代码吗？不加新功能了吗？那不就等于不做产品了吗？

但图书馆给了我一个完全不同的思路：**几十万本书不是问题，几十万本没分类的书才是问题。**

如果把图书馆的几十万册书全部倒在地上堆成一座山，别说找一本特定的书了，你连走进去都困难。但同样的几十万册书，按楼层、区域、类别、字母排好，任何人都能在几分钟内精准定位。

书还是那些书。数量一本没变。变的是它们的**组织方式**。

回到代码：GetDone Timer的六万行代码，如果每一行都在它该在的位置上，有清晰的分类和归属，那六万行和六千行在"可理解性"上其实没有本质区别。你不需要记住每一行代码——就像你不需要记住图书馆里每一本书的内容——你只需要知道"去哪找"。

**我的项目不是太大了，是没有分类。**

这个认知转换很重要，因为它把一个绝望的问题（"代码太多了怎么办"）变成了一个有解的问题（"怎么给代码分类"）。前者让你想放弃，后者让你想动手。

---

## 你天天在做这件事

说到分类，我突然意识到一件挺讽刺的事。

每个写过代码的人都学过数据结构。你知道在一个无序数组里查找一个元素，时间复杂度是O(n)——从头翻到尾，运气差的话翻完整个数组才找到。你也知道如果换成二叉搜索树，复杂度降到O(log n)——每次比较都砍掉一半的搜索空间。你更知道红黑树通过自平衡规则，保证即使在最坏情况下也维持O(log n)的查找效率。

这些是基础中的基础。每个程序员都能脱口而出。

但你有没有想过：**你在自己的项目里"找代码"这个动作，遵循的是完全一样的规律？**

一个没有架构的项目，就是一个无序数组。你要找"计时器暂停时的状态保存逻辑"，只能打开一个又一个文件，线性扫描，直到碰巧找到。文件越多，找得越慢。O(n)。

一个有分层架构的项目，就像有了一层索引。"状态保存是逻辑层的事，不是界面层的，也不是数据层的。" 一个判断，砍掉三分之二的搜索空间。然后在逻辑层里继续找——还是不少文件，但至少范围缩小了。

一个有更细分类的项目——后面会讲到——就像多了好几层索引。"逻辑层 → 计时器相关 → 状态管理 → 暂停处理。" 每一层分类都在缩小搜索范围，几步就能精准定位。

你花了大量时间学数据结构，就是为了优化程序查找数据的效率。但你的代码本身——**它也是一种数据**。你每天都在"查询"它、"检索"它、"定位"它。你给数据库建索引，你给用户数据排序，你用哈希表做O(1)查找——但你的代码？你的代码还躺在一个"无序数组"里。

你天天帮别人的数据建分类系统，却忘了给自己的代码建一个。

---

## 第一个收纳柜：分层

想通了这一点之后，我开始动手了。

第一步很直觉：给代码分大类。就像图书馆的第一层分类是"楼层"——一楼是期刊，二楼是文学，三楼是科技——我也需要先给代码分几个大类。

怎么分？其实标准很简单。我的代码无非在做三种事情：跟用户交互的（界面）、处理业务规则的（逻辑）、存取数据的（数据）。这三种事情的性质完全不同，把它们分开是最自然的第一刀。

这就是"分层架构"。把代码按技术职责分成几层：

界面层在最上面，负责用户看到的一切——窗口、按钮、卡片、动画。它只管"长什么样"和"用户点了什么"，不管背后的业务规则。

逻辑层在中间，负责所有的业务规则——任务怎么创建、计时器怎么运转、番茄钟到时间了触发什么动作。它是整个应用的大脑，但它不直接跟用户打交道，也不直接碰数据库。

数据层在最下面，负责数据的存取——任务数据存在哪里、怎么读出来、怎么写进去。它只管"数据怎么持久化"，不关心数据是用来干什么的。

三层之间的规则也很简单：**只能向下依赖**。界面层可以调用逻辑层，逻辑层可以调用数据层，但反过来不行。数据层不知道逻辑层的存在，逻辑层不知道界面层的存在。就像图书馆的一楼不需要知道三楼有什么书，但三楼的导览牌会告诉你一楼在哪。

这是我给代码做的第一次分类。第一个收纳柜。

效果怎么样？确实好了不少。

最明显的变化是：很多之前看不见的问题突然冒出来了。当我试着把代码按三层分类时，我发现有两个文件明明在做界面渲染的事，却混在逻辑相关的代码中间。还有一段数据库操作代码，不知道为什么写在了一个界面组件里。这些"放错位置"的代码，以前混在一堆的时候根本注意不到，一分类就暴露了。

**分类的价值不仅在于"找东西更快"，还在于"让错误变得可见"。**

给AI的指令也精准了一些。以前我说"帮我改一下计时器的逻辑"，AI得先搞清楚计时器的逻辑散落在哪些文件里。现在我说"逻辑层里跟计时器相关的代码，帮我改一下暂停行为"——至少AI知道不用去界面层和数据层里翻了。

---

## 但架子上还是乱的

分层之后我高兴了大概一个星期。

然后问题来了。

逻辑层。这一层包含了GetDone Timer所有的业务逻辑——任务的创建、编辑、删除、排序、筛选；番茄钟的启动、暂停、完成、统计；自由计时器的倒计时、正计时、时间调整；任务调度的执行顺序、时间规划；状态管理、数据校验、通知触发……

全部堆在"逻辑层"这一个分类里。

这就好比图书馆的三楼写着"科技类"，你走上去一看——几万本书密密麻麻摆满了整层楼，没有任何进一步的分区。计算机的书挨着物理学，物理学旁边是生物，生物后面突然冒出一本机械工程。你知道你要找的书在三楼没错，但三楼本身就是一片汪洋。

收纳柜有了。三层架子也分好了。但每层架子上的东西还是散乱堆着。

我有了"楼层"级别的索引，查找效率从O(n)进步到了"好一些"——但远远没到O(log n)。我还需要在每层楼里面继续细分：区域、书架、标签。

换成代码的语言：我有了Layer，但Layer内部还需要进一步的分类单元。

每层架子上缺的是什么？

**收纳箱。贴好标签的收纳箱。**

---

**本章小结**

> 六万行代码不是问题，六万行没分类的代码才是问题。
>
> 分层架构是你的第一个收纳柜——把代码按界面、逻辑、数据分成三层架子。它让错误变得可见，让给AI的指令更精准，让"找东西"的效率从无序扫描变成了至少有个方向。
>
> 但每层架子上的东西还是散乱的。逻辑层里任务管理、计时器、状态管理全堆在一起，你知道"在三楼"，但三楼本身就是一团乱麻。
>
> 你还需要收纳箱——贴好标签的那种。下一章，我们来解决这个问题。
