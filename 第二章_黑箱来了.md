# 第二章：黑箱来了

---

有一天我需要做一个产品决策。

GetDone Timer同时支持两种计时模式——番茄钟和自由计时。我想加一个任务调度功能，让用户可以提前规划任务的执行顺序和时间安排。问题是：调度功能应该跟任务管理绑在一起，还是做成一个独立模块？

这不是一个技术问题，是一个产品设计问题。答案取决于现在的项目结构——任务管理模块目前跟哪些东西有关联？它的数据是怎么流动的？如果把调度塞进去，会不会让它变得太臃肿？如果独立出来，需要跟多少个现有模块建立新的连接？

这些问题我本来应该能回答的。三个月前我肯定能回答。但那天我对着屏幕想了很久，发现自己脑子里只有一团模糊的印象——"大概是这样吧"。

我没法做决策。不是因为这个决策有多难，而是因为我不具备做这个决策需要的信息。这些信息就在我的项目里，就在那六万行代码里，但我看不见它们。

前言里讲了我掉队的经历。这一章我想聊点不一样的——不是"我是怎么掉队的"，而是**为什么掉队是必然的**。理解这个机制很重要，因为它不只是我的问题，而是每一个Vibe Coder迟早都会遇到的问题。

---

## 一个不对称的赛跑

Vibe Coding的本质是一场不对称的赛跑。

随着项目规模越来越庞大、代码结构越来越复杂，有两条线在朝相反的方向运动。

一条是AI的能力。项目越大、结构越复杂，AI反而越能体现优势——它处理大规模代码的能力在持续增强，模型在迭代，上下文窗口在扩大，推理能力在提升。代码从一千行膨胀到六万行，AI不仅没有变弱，反而因为工具和模型的进化变得更强了。这条线是往上走的。

另一条是你的理解力。这条线是往下走的。当项目有一千行的时候，你的大脑可以轻松装下整个项目。当项目有一万行的时候，你需要开始有意识地记忆和整理。当项目有三万行的时候，你的大脑已经装不下了——你开始忘记某些模块的存在，开始搞混某些功能的位置，开始对依赖关系产生错误的假设。

一条线在升，一条线在降。随着项目规模的增长，这两条线一定会交叉。

交叉点之前，你清醒，AI也强，一切顺利。

交叉点之后，才是真正让人焦虑的地方——项目继续膨胀，AI的能力继续上升，而你的理解力继续下降。**剪刀差越来越大。** AI能处理的复杂度越来越高，而你能看清的东西越来越少。你们之间的鸿沟不是保持不变，而是随着项目规模的增长在加速扩大。

**这个交叉点不是"可能"会来，是"一定"会来。** 只要你持续使用Vibe Coding往项目里加东西，代码量就会持续增长，而你的大脑容量不会跟着增长。这是一个数学问题，不是能力问题。

---

## AI也有它看不见的地方

说到这里我想替AI说句公道话——也指出它真实的边界。

AI写代码确实嘎嘎乱杀，这一点前面已经说了很多。但AI并不是万能的，它有一个经常被忽略的局限：**上下文窗口**。

什么意思呢？AI每次跟你对话的时候，它能"看见"的信息量是有限的。它不能一次性读完你的六万行代码。它看到的是你给它的那部分——也许是几个文件，也许是一段描述，也许是一个报错信息。它基于它看到的这些做出判断。

项目小的时候，这不是问题。你可以把整个项目丢给它，它全看得见。但项目大了之后，AI每次只能看到局部。它在局部范围内的判断可能是对的，但它不一定知道这个局部之外还有什么。

还有一个问题：**AI没有跨会话的天然记忆**。这次对话里你告诉它"TaskManager负责所有任务相关的逻辑"，下次新开一个对话，它就不记得了。你需要重新告诉它，或者给它看相关的代码。

这意味着什么？

意味着当项目膨胀到一定程度，**你和AI都看不见全局**。你看不见是因为大脑装不下。AI看不见是因为上下文窗口装不下。你们各自看到的都是项目的一部分，但没有人——包括AI在内——对整个项目有完整的认知。

这不影响AI执行具体任务的能力。你让它改一个按钮颜色，它改得很好。你让它加一个数据字段，它加得也没问题。但涉及到跨模块的决策、全局性的调整、架构层面的取舍——AI的判断质量直接取决于你提供的上下文质量。

**你的指令越精准，AI表现越好。你的指令越模糊，AI越容易偏。**

所以问题又回到了你身上：在你自己都看不清全局的情况下，你怎么给AI提供精准的上下文？

---

## 掉队的三个信号

这种"看不清全局"的状态，在日常开发中会表现为三个具体的信号。如果你在Vibe Coding的过程中发现自己中了其中两个以上，那你可能已经掉队了。

**第一个信号：决策瘫痪。**

你想加一个新功能，但你不知道它应该放在哪里。不是"有两个选项在纠结"，而是"连选项都列不出来"。你不清楚现在的项目结构长什么样，所以你没法判断新功能应该挂在哪个模块下面。最后你要么随便选一个位置凑合，要么干脆把决策丢给AI——"你觉得放哪里好？"

**第二个信号：盲目指挥。**

你告诉AI"帮我改一下这个功能"，但你给的位置是错的，或者你遗漏了某个相关的模块。AI照你说的改了，结果别的地方坏了。你又让AI去修那个坏掉的地方，结果引发了第三个问题。来回折腾几轮之后，你发现问题的根源其实在一个你完全没想到的地方。

这种"改了A坏了B、修了B又崩了C"的连锁反应，不是AI的执行力有问题，是你指挥的方向有问题。

**第三个信号：重复折腾。**

同一个功能改了撤、撤了改，反复三四次。每一次你都觉得"这次应该对了"，但结果总是差那么一点。不是因为AI实现得不好，而是因为你每次给的需求描述都不够完整——你遗漏了某个约束条件、忘记了某个边界情况、没考虑到某个模块的依赖。这些遗漏的根源是同一个：你看不清全局。

如果这三个场景听起来似曾相识，别慌。不是你的问题。

---

## 恶性循环

这三个信号不是孤立的，它们会互相叠加，形成一个恶性循环。

你看不清项目全貌，所以给AI的指令不够精准。AI忠实地执行了不精准的指令，代码在一次次不够精准的修改中变形——该放在一起的东西被拆开了，不该耦合的模块被绑在了一起，临时的权宜之计变成了永久的技术债务。

项目结构变形之后，你更看不清了。更看不清，指令就更不精准。更不精准，项目就变形得更厉害。

这是一个自我强化的下螺旋。而且它有一个让人绝望的特点：**你越努力，它转得越快。** 因为你越努力就意味着你在往项目里加更多东西，而每加一样东西，你对全局的理解就又稀释一点。

Vibe Coding的速度在这里变成了双刃剑。如果你写代码很慢——比如传统手写——那代码膨胀的速度也慢，你的大脑至少有时间慢慢消化。但Vibe Coding太快了，快到你来不及消化上一个功能，下一个功能已经加进去了。

随着项目规模越来越庞大，代码结构越来越复杂，AI越来越得心应手，而你越来越迷路。

**这就是Vibe Coding的悖论：AI越厉害，你越容易迷路。**

---

## 这不是你的问题

我花了很长时间才接受一件事：掉队不是因为我不够聪明、不够努力、或者不够有经验。

掉队是Vibe Coding的**结构性缺陷**。

Vibe Coding优化的是"快速产出"——想到什么就做什么，功能迅速上线。它在这一点上做到了极致。但它没有任何内建机制帮助你维护"全局理解"。没有任何东西逼你停下来想一想"我现在的项目长什么样"。没有任何工具帮你把脑子里那幅越来越模糊的地图重新画清楚。

传统软件工程有各种仪式感十足的做法来对抗这个问题——代码评审、架构文档、设计讨论。你可以觉得它们繁琐，但它们至少强制你定期思考全局。Vibe Coding把这些全跳过了——连同它们提供的那一点点"全局清醒"。

所以这不是一个能通过"更努力"来解决的问题。你不可能通过更频繁地Vibe Coding来弥补Vibe Coding造成的全局理解丧失。那只会让问题更严重。

你需要的是一样不同的东西。

你需要一个方法，让你在继续享受Vibe Coding的速度和快感的同时，定期把你的项目"看清楚"。不是看懂每一行代码——你不需要。而是看清全局：项目里有哪些东西、它们是怎么组织的、谁跟谁有关系。

换句话说，你需要一个收纳系统。一个能让塞满东西的房间重新变得井然有序的方法。

这就是下一章的内容。

---

**本章小结**

> 黑箱不是因为你不够聪明——它是Vibe Coding的结构性缺陷。
>
> 随着项目规模膨胀，AI的能力在上升，你的理解力在下降。这两条线一定会交叉，交叉之后剪刀差越来越大——AI越来越强，你越来越迷路。
>
> 掉队的信号是：做不了决策、指挥偏了方向、反复折腾同一个功能。这三个信号会形成恶性循环，而且你越努力转得越快。
>
> 你不需要跑得比AI快。你需要一个收纳系统——让你在AI狂飙突进的同时，始终看得清自己的项目。
