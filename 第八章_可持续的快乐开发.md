# 第八章：Vibe Coding + 全景照 = 可持续的快乐开发

---

前七章走了一条完整的路：从 Vibe Coding 的蜜月期开始，经历黑箱困境，学会了分层（Layer）和分区（Zone），然后用 Layer-Zone Tree 给项目拍了一张全景照，还学会了让 AI 帮你拍。

工具齐了。方法也有了。

这一章回答最后一个问题：**这些东西怎么融入你的日常开发？**

不是说让你从明天开始每天花两小时搞架构——那就不是 Vibe Coding 了。而是找到一种节奏，让你既能享受 Vibe Coding 的速度和快感，又不会在项目膨胀的时候失去方向。

---

## 可持续的工作流

把整本书浓缩成一个工作流，就是两件事交替进行：

**日常：Vibe Coding。**

想到什么功能就做。AI 帮你写代码。快速迭代。不需要每写一段代码就停下来检查架构——那会把你的节奏彻底打乱。Vibe Coding 的核心就是"跟着直觉走"，这个不要变。

**定期：拍一张全景照。**

每隔一段时间（2-4 周，或者一个大功能做完之后），让 AI 重新分析一次代码，输出新的 Tree 和 Visuals。然后跟上一次的照片对比——看看项目变了什么。

就这两件事。日常 Vibe Coding，定期拍照对比。

具体来说，定期拍照之后你会做三个动作：

**第一，看变化。**

新 Tree 和旧 Tree 放在一起，差异一目了然。新增了哪些 Zone？哪些 Zone 的文件数量在增长？有没有新的依赖违规？大部分变化是正常的——你加了新功能，自然会多出 Zone 和文件。你要关注的是异常信号。

**第二，标记问题。**

发现了异常就标记下来。某个 Zone 从 8 个文件膨胀到了 15 个——标记"下次考虑拆分"。出现了一条新的 🟡 依赖——标记"下次重构时处理"。有一个文件跑到了错误的 Layer——标记"找机会移回去"。

注意：标记问题不等于立刻修复。大部分问题可以攒着，等到合适的时候一起处理。只有 🔴 级别的违规（反向依赖、循环依赖）才需要尽快处理，因为它们会让 Zone 边界失效，越拖越难修。

**第三，继续 Vibe Coding。**

看完照片、标记完问题，关掉 Tree 文件，继续你的日常开发。该加功能加功能，该改 bug 改 bug。下一次定期拍照的时候，再来看看那些标记的问题有没有恶化。

```
日常                        定期
┌─────────────┐            ┌───────────────┐
│  Vibe Coding │    每      │  AI 拍全景照    │
│  AI 嘎嘎乱杀 │  2-4 周   │  新旧 Tree 对比  │
│  快速迭代     │ ──────→  │  标记异常信号    │
│  跟着直觉走   │           │  🟢🟡 先记着     │
│              │    ←──────│  🔴 尽快处理     │
│  继续开发     │           │                 │
└─────────────┘            └───────────────┘
```

这个循环的核心原则是：**全景照是后台运行的架构守护者，不是前台的流程审批。**

你不需要每次改代码之前先查 Tree，不需要每加一个文件就更新 Zone 映射，不需要在开始写代码之前画架构图。这些事情会杀死 Vibe Coding 的节奏。

你需要做的只是定期退后一步，看一眼全局。就像开长途车——你不需要每秒钟都检查导航，但你需要偶尔瞟一眼，确认自己还在正确的路上。

---

## 新项目：从 Day 1 就有全景照

如果你正要开始一个全新的项目，有一个巨大的优势：你可以从第一天就建立全景照。

上一章讲了三种拍照方式，其中 Top-down 就是为新项目准备的。在写第一行代码之前，先规划好 Layer-Zone 结构。

**具体怎么做？**

**第一步：列出核心功能。**

不需要列得很细，只需要列出项目的主要功能模块。比如你要做一个任务管理应用：

- 任务的创建和管理
- 计时器（番茄钟 + 自由计时）
- 日程规划
- 数据持久化
- 用户设置

**第二步：确定 Layer 结构。**

大多数项目三层就够了——UI、Logic、Data。如果你预计会有比较复杂的 ViewModel 逻辑（比如需要在 UI 和 Logic 之间做大量数据转换），可以加一个 Glue 层。如果有比较多的跨层共享的纯数据模型，可以加一个 Models 层。

不确定的话，从三层开始。后面发现不够再加，比一开始设计过度要好。

**第三步：为每个功能规划初始 Zone。**

每个核心功能在对应的 Layer 里各有一个 Zone：

```
UI Layer：    TaskUIZone, TimerUIZone, ScheduleUIZone, SettingsUIZone
Logic Layer： TaskZone, TimerZone, ScheduleZone, SettingsZone
Data Layer：  PersistenceZone
```

这就是你的蓝图版 Tree。很粗糙，很简单——但它足够了。

**第四步：把蓝图给 AI，让 AI 按 Zone 来写代码。**

你告诉 AI："现在要实现任务创建功能，代码放在 TaskZone（逻辑层）和 TaskUIZone（界面层）。" AI 从一开始就在正确的 Zone 里写代码，而不是随便找个地方塞。

**从 Day 1 就有全景照的好处**：你不会积累黑箱。每一行新代码写出来的时候，它就已经在正确的位置上了。项目长大的过程中，你始终看得清它长什么样。

不需要等到"项目乱了"再来整理——因为从一开始就没乱过。

当然，蓝图不可能一成不变。随着开发推进，你会发现需要新的 Zone，需要拆分某些 Zone，需要调整依赖关系。这都是正常的。蓝图是起点，不是终点。定期用 Calibration 拍照对比，看看实际代码和蓝图的偏差，该调整就调整。

---

## 已有项目：渐进式改造

更常见的情况是：你的项目已经 Vibe Coding 了一段时间，代码已经膨胀了，你现在想引入全景照。

好消息：**不需要推倒重来。**

你不需要停下开发，花一周时间重组项目结构。你也不需要移动任何文件、改任何目录。记住第四章的结论——Zone 是逻辑概念，不是物理文件夹。引入 Zone 的成本是零。

渐进式改造分四步：

**第一步：让 AI 做一次 Bottom-up 分析。**

把 AI Playbook 和项目源码丢给 AI，让它输出 Tree 和 Visuals。这是你的第一张全景照——一张现状照。不管项目多乱，先拍下来，看清楚再说。

**第二步：审核照片，找到最大的痛点。**

你拿到 Tree 之后，先不要试图修复所有问题。看几个关键指标：

- 有没有 🔴 级别的依赖违规？（反向依赖、循环依赖）
- 有没有严重膨胀的 Zone？（超过 15 个文件的）
- 有没有文件明显放错了位置？（UI 组件混在逻辑层之类的）

找到最痛的一两个点。

**第三步：从最痛的地方开始修。**

一次只处理一个问题。比如你发现 Logic 层有一条反向依赖——一个逻辑文件直接引用了 UI 组件。告诉 AI："这个文件不应该依赖 UI 层，帮我通过回调或者协议解耦。" AI 改完，这条 🔴 就消除了。

又比如你发现 TaskZone 有 18 个文件，明显太大了。告诉 AI："TaskZone 帮我分析一下能不能拆分。" AI 可能会建议把"任务排序"相关的文件拆出一个 TaskSortingZone，或者把"任务状态流转"拆出一个 TaskStateZone。你看方案，判断合不合理，拍板。

**第四步：定期拍照，持续迭代。**

修完最痛的问题之后，回到日常 Vibe Coding。等下一次定期拍照的时候，你会发现：上次标记的 🔴 消失了，某些 🟡 可能变好了也可能变坏了，可能又出现了新的问题。

这就是渐进式改造的节奏：**不追求一步到位，每次只处理最痛的那一两个问题。** 几轮下来，项目的架构健康度会持续改善——而你从来没有为此停下过开发。

用一个时间线来看 GetDone Timer 的改造过程：

```
第 1 次拍照（现状照）：
  160 个文件，33 个 Zone
  🔴 0 条  🟡 1 条  🟢 2 条
  2 个文件明确放错位置
  → 标记问题，继续开发

第 2 次拍照（4 周后）：
  新增 2 个 Zone（StatisticsZone、StatisticsUIZone）
  🟡 的那条依赖没有恶化，暂时不动
  ScheduleUIZone 从 16 个文件涨到 19 个 → 标记"考虑拆分"
  → 继续开发

第 3 次拍照（又 4 周后）：
  ScheduleUIZone 继续膨胀到 22 个文件 → 决定拆分
  让 AI 把 ScheduleUIZone 拆成 ScheduleDayUIZone 和 ScheduleWeekUIZone
  拆完重新拍照确认：结构清晰了，继续开发
```

每次拍照几分钟，看照片十几分钟，处理问题可能半小时到一小时。这就是全部的额外投入。换来的是你始终看得清项目长什么样。

---

## 实用建议

几条在实践中积累的经验，帮你少走弯路。

### 给 AI 完整源码，不只是目录结构

让 AI 做 Bottom-up 分析的时候，一定要给完整的源码文件。只给文件名和目录树是不够的——AI 需要读代码内容才能判断一个文件到底在做什么。

文件名可以骗人。一个叫 `GoogleSignInWindow.swift` 的文件放在 Logic 目录里，看名字和位置好像是逻辑层的认证代码。但 AI 读完代码发现——它是一个 WKWebView 弹窗，纯 UI 组件，应该属于 UI 层。如果 AI 只看文件名和路径，就会分错。

### 先处理 🔴，🟢 和 🟡 可以等

依赖违规的三级分类不是摆设。🔴 意味着 Zone 边界正在失效——两个 Zone 互相依赖，改一个可能连带另一个坏掉，AI 工作时的隔离性也会降低。这种问题拖得越久越难修。

🟢 和 🟡 通常是可控的。一个简单场景跳了一层（🟢），或者某个直连暂时不影响功能（🟡），这些可以攒到合适的时候一起处理。不要因为追求"全绿"而打断你的开发节奏。

### 膨胀的 Zone 一定要拆

一个 Zone 超过 10-15 个文件，就该考虑拆分了。不拆的后果是什么？你让 AI "改 ScheduleUIZone 里的 Week 视图"，AI 要读 19 个文件才能理解这个 Zone 的全貌——其中有一半是跟 Week 视图完全无关的 Day 视图代码。上下文窗口被浪费，AI 的注意力被稀释。

拆分之后，你说"改 ScheduleWeekUIZone 里的日期切换"，AI 只需要读 8 个文件，全部跟 Week 视图相关，注意力百分百集中。

拆分的判断不需要你自己做——告诉 AI "这个 Zone 太大了，帮我分析怎么拆"，AI 会给你方案，你来拍板。

### 物理位置和逻辑 Zone 不一致？先标记，不急

Tree 可能会告诉你一些文件的物理目录和逻辑归属不一致。比如一个 UI 组件放在了 Logic 目录里。

这种不一致不紧急。文件放在哪个文件夹不影响代码运行，也不影响 AI 分析（因为 AI 是按代码内容判断归属的，不是按文件夹路径）。先在 Tree 里标记出来就行。

如果哪天你决定做一轮目录重构——把文件移到跟逻辑归属一致的目录下——那时候再处理。但这完全是可选的。很多项目一直带着这种不一致也运行得好好的。

### 不要让全景照变成流程审批

这是最重要的一条。

全景照的价值在于"让你看见"。但如果你把它变成了一种审批流程——每次加功能之前先查 Tree、每次改代码之后立刻更新 Zone 映射、每次 AI 输出代码先验证是否符合 Zone 边界——那你就把一个轻量的认知工具变成了沉重的流程负担。

**全景照是后台守护者，不是前台审批员。**

你该加功能加功能，该迭代迭代。只在定期拍照的时候才看 Tree。就像车载导航——它在后台静静运行，你偶尔瞟一眼确认方向，但你不会每踩一脚油门都停下来看导航。

如果你发现自己开始为了"保持 Tree 的完美"而放慢了开发速度，那说明你用过头了。退回来，回到"日常 Vibe Coding + 定期拍照"的节奏。

---

## 从黑箱到全景照

回头看一下我们走过的路。

前言里的困境是：项目越来越大，你看不清它长什么样了。你在猜，而不是在判断。AI 越强，你越容易迷路。

第一章到第二章建立了问题的本质：不是代码太多了，是你没有组织代码的方法。指挥官失去了地图，精锐部队再强也没用。

第三章到第五章给了你分类的工具：Layer（收纳柜）把代码按技术职责分层，Zone（收纳箱）在每层内部按业务职责分区，每个文件都有了明确的归属。分类系统建好了。

第六章到第七章把分类系统变成了一张可见的地图：Layer-Zone Tree 是你项目的全景照片，AI 帮你拍，你来看。定期重新拍照，新旧对比，变化一目了然。

这一章把所有东西串成了一个可持续的工作流：日常 Vibe Coding 不变，定期拍照看全局。新项目从 Day 1 就有蓝图，已有项目渐进式改造。

**一条线走完：从"看不见"到"看得清"。**

这不是什么高深的方法论。归根到底就是一个朴素的想法：

给代码分好类（Layer + Zone），然后拍张全景照（Layer-Zone Tree）。

分类让每个文件有了归属。全景照让你看见全局。看见了，你给 AI 的指令就精准了。指令精准了，AI 的执行就不会偏了。不偏了，项目就不会失控了。

这才是 Vibe Coding 真正可持续的方式——不是靠"写代码更快"来解决问题，而是靠"看得更清"来保持掌控。

---

## 指挥官的地图

最后说一个感受。

我做 GetDone Timer 的这段经历，最大的教训不是技术上的，而是认知上的。

AI 时代的开发者，最稀缺的能力不是写代码——AI 比你写得好、写得快。最稀缺的能力是**理解全局**。知道项目长什么样，知道该往哪里加东西，知道改一个地方会影响哪些地方。

这种能力不会随着 AI 变强而过时。恰恰相反，AI 越强，产出的代码越多，项目膨胀得越快，你就越需要一张地图来保持方向感。

Layer-Zone Tree 就是这张地图。

它不帮你写代码——AI 写得比你好。
它不帮你改 bug——AI 改得比你快。
它只做一件事：**让你看见。**

看见项目的全貌，看见每个文件在哪里，看见 Zone 之间的依赖关系，看见哪里在膨胀，看见哪里有违规。

一个看得清全局的指挥官，加上一支执行力拉满的 AI 部队——这个组合才是真正的势不可挡。

AI 会越来越强。代码会越来越多。项目会越来越复杂。

但只要你手里有一张全景照——你就不会迷路。

---

**本章小结**

> 可持续的工作流：日常 Vibe Coding（跟着直觉走，AI 嘎嘎乱杀）+ 定期拍全景照（每 2-4 周，AI 分析代码，新旧 Tree 对比）。
>
> 新项目从 Day 1 就可以有全景照——Top-down 规划初始 Zone，AI 按 Zone 写代码，不积累黑箱。
>
> 已有项目不需要推倒重来——Bottom-up 先拍一张现状照，找到最痛的问题，一次修一两个，渐进式改善。
>
> 全景照是后台的架构守护者，不是前台的流程审批。不要让它拖慢你的 Vibe Coding 节奏。
>
> 一个看得清全局的指挥官 + 一支执行力拉满的 AI 部队 = 势不可挡。
